<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>Generator.scala</title>
  <link rel="stylesheet" href="../.docco/main.css"/>
  <script type="text/javascript" src="../.docco/highlight.js">
  </script>
  <script type="text/javascript">
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>
<div id="container">
  <div id="background"></div>
  <table cellspacing="0" cellpadding="0">
    <thead>
    <tr>
      <th class="docs">
        <h1><a href="../index.html" title="Back to index">&larr;</a>&nbsp;&nbsp;Generator.scala</h1>
      </th>
      <th class="code"></th>
    </tr>
    </thead>
    <tbody>
    <tr id="section-0">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-0">#</a>
        </div>
      <p></p>
      </td>
      <td class="code">
        <pre><code>package it.cnr.aquamaps

import scala.collection.JavaConversions._
import scala.collection.JavaConverters._

import stopwatch.Stopwatch

import com.google.inject._
import com.google.inject.name._

import au.com.bytecode.opencsv.CSVReader
import au.com.bytecode.opencsv.CSVWriter
import au.com.bytecode.opencsv.bean.ColumnPositionMappingStrategy
import org.supercsv.io.CsvListWriter
import org.supercsv.prefs.CsvPreference
import java.io._
import java.util.zip._
import org.apache.commons.io.IOUtils
import Watch.timed</code></pre>
      </td>
    </tr>
    <tr id="section-1">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-1">#</a>
        </div>
      <p>!## Generator</p>
      </td>
      <td class="code">
        <pre><code></code></pre>
      </td>
    </tr>
    <tr id="section-2">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-2">#</a>
        </div>
      <p>! This is the heart of the scenario. The entry point invokes this method once for each partition.</p>
      </td>
      <td class="code">
        <pre><code>trait Generator {
  def computeInPartition(p: Partition)
}</code></pre>
      </td>
    </tr>
    <tr id="section-3">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-3">#</a>
        </div>
      <p>! This is a local implementation of the HSPEC generator core.</p>
      </td>
      <td class="code">
        <pre><code>class HSPECGenerator @Inject() (
  val hspenLoader: Loader[HSPEN],
  val emitter: Emitter[HSPEC],
  val fetcher: Fetcher[HCAF],
  val algorithm: HspecAlgorithm) extends Generator {</code></pre>
      </td>
    </tr>
    <tr id="section-4">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-4">#</a>
        </div>
      <p>! HSPEN table is loaded only once</p>
      </td>
      <td class="code">
        <pre><code>  lazy val hspen = hspenLoader.load</code></pre>
      </td>
    </tr>
    <tr id="section-5">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-5">#</a>
        </div>
      <p>! Then for each partition:</p>
      </td>
      <td class="code">
        <pre><code>  def computeInPartition(p: Partition) {
    val startTime = System.currentTimeMillis

    timed(&quot;partition %s&quot;.format(p.start)) {
      val records = for {</code></pre>
      </td>
    </tr>
    <tr id="section-6">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-6">#</a>
        </div>
      <p>! * fetch hcaf rows for that partition</p>
      </td>
      <td class="code">
        <pre><code>        hcaf &lt;- fetcher.fetch(p.start, p.size)</code></pre>
      </td>
    </tr>
    <tr id="section-7">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-7">#</a>
        </div>
      <p>! * for each hacf row compute a list of output hspec rows</p>
      </td>
      <td class="code">
        <pre><code>        hspec &lt;- algorithm.compute(hcaf, hspen)</code></pre>
      </td>
    </tr>
    <tr id="section-8">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-8">#</a>
        </div>
      <p>! * emit each generated hspec row using our pluggable emitter</p>
      </td>
      <td class="code">
        <pre><code>      } emitter.emit(hspec)
    }
  }

}

object HSPECGenerator {
  val startTime = System.currentTimeMillis
}</code></pre>
      </td>
    </tr>
    <tr id="section-9">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-9">#</a>
        </div>
      <p>!## Fetcher</p>

<p>A <code>Fetcher</code> is a component that reads some data from a db. It's mostly useful for loading partitions of the HCAF table.</p>

<p>A <code>Fetcher</code> differs from a <code>Loader</code>, in that it supports the fetch by range functionality, and it's implementation may be unable
to load the whole content in one piece.</p>

<p>Please see the <a href="MemoryDB.scala.html">MemoryFetcher</a> for a concrete fetcher.</p>
      </td>
      <td class="code">
        <pre><code>trait Fetcher[A] {
  def fetch(key: String, size: Long): Iterable[A]
  def shutdown = {}
}</code></pre>
      </td>
    </tr>
    <tr id="section-10">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-10">#</a>
        </div>
      <p>!## Emitter</p>

<p><code>Generator</code> uses <code>Emitter</code> to output data. Usually the <code>Emitter</code> emits <code>HSPEC</code> records.</p>
      </td>
      <td class="code">
        <pre><code>trait Emitter[A] {
  def emit(record: A)

  def flush
}</code></pre>
      </td>
    </tr>
    <tr id="section-11">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-11">#</a>
        </div>
      <p>!
If a table is a <code>Product</code> (a case class is a Product) then we can serialize it to csv via this emitter.</p>
      </td>
      <td class="code">
        <pre><code>class CSVEmitter[A &lt;: Product] @Inject() (val sink: PositionalSink[A]) extends Emitter[A] {</code></pre>
      </td>
    </tr>
    <tr id="section-12">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-12">#</a>
        </div>
      <p>!</p>
      </td>
      <td class="code">
        <pre><code>  def emit(record: A) = sink.write(record.productIterator.map(_.toString).toArray)

  def flush = sink.flush
}</code></pre>
      </td>
    </tr>
    <tr id="section-13">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-13">#</a>
        </div>
      <p>!## Table readers</p>

<p>A table reader declares a data source for a <code>PositionalSource</code> (or others). We exploit phantom types to easily bind
a particular implementation of a table reader to a given PositionalSource via Guice.</p>
      </td>
      <td class="code">
        <pre><code>trait TableReader[A] {
  def reader: Reader
}</code></pre>
      </td>
    </tr>
    <tr id="section-14">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-14">#</a>
        </div>
      <p>! We can read data from the filesystem. Gzip files are supported</p>
      </td>
      <td class="code">
        <pre><code>class FileSystemTableReader[A] @Inject() (val name: String) extends TableReader[A] {
  def reader = {
    if (name endsWith &quot;.gz&quot;)
      new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(name))))
    else
      new FileReader(name)
  }
}</code></pre>
      </td>
    </tr>
    <tr id="section-15">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-15">#</a>
        </div>
      <p>!## Table writers</p>

<p>A table writer binds a writer for a <code>PositionalSink</code> with a phantom type.</p>
      </td>
      <td class="code">
        <pre><code>trait TableWriter[A] {
  def writer: Writer
}</code></pre>
      </td>
    </tr>
    <tr id="section-16">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-16">#</a>
        </div>
      <p>! We can read data from the filesystem. Gzip files are supported</p>
      </td>
      <td class="code">
        <pre><code>class FileSystemTableWriter[A] @Inject() (val name: String) extends TableWriter[A] {
  def writer = {
    if (name endsWith &quot;.gz&quot;)
      new BufferedWriter(new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(name))))
    else
      new FileWriter(name)
  }
}</code></pre>
      </td>
    </tr>
    <tr id="section-17">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-17">#</a>
        </div>
      <p>!## Sources and Sinks</p>
      </td>
      <td class="code">
        <pre><code></code></pre>
      </td>
    </tr>
    <tr id="section-18">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-18">#</a>
        </div>
      <p>! Loads data from a positional source, like a table with ordered columns but without column names</p>
      </td>
      <td class="code">
        <pre><code>trait PositionalSource[A] {
  def read: Iterable[Array[String]]
}

trait PositionalSink[A] {
  def write(row: Array[String])

  def flush {}
}</code></pre>
      </td>
    </tr>
    <tr id="section-19">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-19">#</a>
        </div>
      <p>! We treat CSV as a positional source, we rely on the fact that the columns are in a particular order</p>
      </td>
      <td class="code">
        <pre><code>class CSVPositionalSource[A] @Inject() (val tableReader: TableReader[A]) extends PositionalSource[A] {
  def read = new CSVReader(tableReader.reader).readAll
}</code></pre>
      </td>
    </tr>
    <tr id="section-20">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-20">#</a>
        </div>
      <p>! We can also write into a CSV with a PositionalSink. The phantom type parameter is again used
 only as a type safe and dependency injection wiring aid</p>
      </td>
      <td class="code">
        <pre><code>class CSVPositionalSink[A] @Inject() (val tableWriter: TableWriter[A]) extends PositionalSink[A] {
  val lowWriter = tableWriter.writer
  val writer = new CsvListWriter(lowWriter, CsvPreference.STANDARD_PREFERENCE)

  def write(row: Array[String]) = writer.write(row);

  override def flush = writer.close
}</code></pre>
      </td>
    </tr>
    <tr id="section-21">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-21">#</a>
        </div>
      <p>!## Loaders</p>
      </td>
      <td class="code">
        <pre><code></code></pre>
      </td>
    </tr>
    <tr id="section-22">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-22">#</a>
        </div>
      <p>! A <code>Loader</code> loads a whole db in as an iterable.</p>
      </td>
      <td class="code">
        <pre><code>trait Loader[A] {
  def load: Iterable[A]
  def shutdown = {}
}</code></pre>
      </td>
    </tr>
    <tr id="section-23">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-23">#</a>
        </div>
      <p>! Used to load the <code>HSPEN</code> table in memory 
trait HSPENLoader extends Loader[HSPEN]</p>
      </td>
      <td class="code">
        <pre><code></code></pre>
      </td>
    </tr>
    <tr id="section-24">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-24">#</a>
        </div>
      <p>! Used to load a <code>HCAF</code> table partition in memory 
trait HCAFLoader extends Loader[HCAF]</p>
      </td>
      <td class="code">
        <pre><code></code></pre>
      </td>
    </tr>
    <tr id="section-25">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-25">#</a>
        </div>
      <p>! Load the <code>HSPEN</code> table from a positional tabular source (i.e. the colums are known by position).</p>
      </td>
      <td class="code">
        <pre><code>class TableHSPENLoader @Inject() (val tableLoader: PositionalSource[HSPEN]) extends Loader[HSPEN] {
  def load = tableLoader.read map HSPEN.fromTableRow
}</code></pre>
      </td>
    </tr>
    <tr id="section-26">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-26">#</a>
        </div>
      <p>! Load the <code>HCAF</code> table from a positional tabular source (i.e. the colums are known by position).</p>
      </td>
      <td class="code">
        <pre><code>class TableHCAFLoader @Inject() (val tableLoader: PositionalSource[HCAF]) extends Loader[HCAF] {
  def load = tableLoader.read map HCAF.fromTableRow
}</code></pre>
      </td>
    </tr>
    <tr id="section-27">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-27">#</a>
        </div>
      <p>! Load the <code>HSPEC</code> table from a positional tabular source (i.e. the colums are known by position). This shouuldn't be useful, but we currently use it to merge
 multiple HSPEC outputs in a single big csv (inefficient but useful for test).</p>
      </td>
      <td class="code">
        <pre><code>class TableHSPECLoader @Inject() (val tableLoader: PositionalSource[HSPEC]) extends Loader[HSPEC] {
  def load = tableLoader.read map HSPEC.fromTableRow
}</code></pre>
      </td>
    </tr>
    <tr id="section-28">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-28">#</a>
        </div>
      <p>! A <code>ColumnStoreLoader</code> provides the data differently. It returns data as unordered name-value pairs. Some data sources, like
 table stores can returns data like this.</p>
      </td>
      <td class="code">
        <pre><code>trait ColumnStoreLoader[A] {
  def read: Iterable[Map[String, String]]
}</code></pre>
      </td>
    </tr>
    <tr id="section-29">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-29">#</a>
        </div>
      <p>! We can provide a column/value output from a csv string. Not very useful, but might be useful for testing</p>
      </td>
      <td class="code">
        <pre><code>class CSVColumnStoreLoader[A] @Inject() (val tableReader: TableReader[A]) extends ColumnStoreLoader[A] {

  class ColumnNameMapper(reader: CSVReader) extends ColumnPositionMappingStrategy[A] {
    captureHeader(reader)

    def name(pos: Int) = getColumnName(pos)
    def columns = header

    def asMap(row: Array[String]) = Map(columns zip row: _*)
  }

  def read = {
    val csv = new CSVReader(tableReader.reader)
    val mapper = new ColumnNameMapper(csv)

    csv.readAll map mapper.asMap
  }
}</code></pre>
      </td>
    </tr>
    <tr id="section-30">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-30">#</a>
        </div>
      <p>! Load the <code>HSPEN</code> table from a column store source</p>
      </td>
      <td class="code">
        <pre><code>class ColumnStoreHSPENLoader @Inject() (val columnStoreLoader: ColumnStoreLoader[HSPEN]) extends Loader[HSPEN] {
  def load = columnStoreLoader.read map HSPEN.build
}</code></pre>
      </td>
    </tr>
  </table>
</div>
</body>
</html>