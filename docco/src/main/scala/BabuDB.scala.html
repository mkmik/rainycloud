<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>BabuDB.scala</title>
  <link href="http://circumflex.ru/css/docco.css"
        rel="stylesheet"
        type="text/css"
        media="screen, projection"/>
  <script type="text/javascript" src="http://circumflex.ru/js/highlight.pack.js">
  </script>
  <script type="text/javascript">
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>
<div id="container">
  <table cellspacing="0" cellpadding="0">
    <thead>
    <tr>
      <th class="docs">
        <h1><a href="../../../index.html" title="Back to index">&larr;</a>&nbsp;&nbsp;BabuDB.scala</h1>
      </th>
      <th class="code"></th>
    </tr>
    </thead>
    <tbody>
    <tr id="section-0">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-0">#</a>
        </div>
      
      </td>
      <td class="code">
        <pre class="scala"><code>package it.cnr.aquamaps

import com.google.inject._
import com.google.inject.name._

import org.xtreemfs.babudb._
import org.xtreemfs.babudb.config._
import org.xtreemfs.babudb.log._
import org.xtreemfs.babudb.lsmdb._

import java.io._
import scala.collection.JavaConversions._
import scala.collection.JavaConverters._

import com.google.inject._
import uk.me.lings.scalaguice.InjectorExtensions._
import com.google.inject.name._
import com.google.inject.name.Names.named
import uk.me.lings.scalaguice.ScalaModule

import HCAF._
import HSPEN._

case class BabuDBModule() extends AbstractModule with ScalaModule {
  def configure() {
    bind[Loader[HSPEN]].annotatedWith(named(&quot;forBabu&quot;)).to(classOf[TableHSPENLoader]).in(classOf[Singleton])

    bind[Serializer[HCAF]].toInstance(AvroSerializer[HCAF]())
    bind[Serializer[HSPEN]].toInstance(AvroSerializer[HSPEN]())
  }

  @Provides
  @Singleton
  def hcafFetcher(loader: Loader[HCAF], serializer: Serializer[HCAF]): Fetcher[HCAF] = new BabuDBFetcher(&quot;hcaf&quot;, loader, serializer)

  @Provides
  @Singleton
  def hspenLoader(@Named(&quot;forBabu&quot;) loader: Loader[HSPEN], serializer: Serializer[HSPEN]): Loader[HSPEN] = new BabuDBLoader(&quot;hspen&quot;, loader, serializer)
}


trait BabuDB[A &lt;: Keyed] {
  val loader: Loader[A]
  val dbName: String
  val serializer: Serializer[A]

  val databaseSystem = BabuDBFactory.createBabuDB(new ConfigBuilder().setDataPath(&quot;/tmp/babudb&quot;).setLogAppendSyncMode(DiskLogger.SyncMode.ASYNC).build())
  val dbman = databaseSystem.getDatabaseManager();

  val db = getDb

  def stop {
    db.shutdown
    databaseSystem.shutdown()
  }

  def getDb() = {
    try {
      dbman.createDatabase(dbName, 1)
      val db = dbman.getDatabase(dbName);
      reload(db)
      databaseSystem.getCheckpointer().checkpoint()
      db
    } catch {
      case _: BabuDBException =&gt; dbman.getDatabase(dbName);
    }
  }

  def reload(db: Database) = {
    print(&quot;caching %s ...&quot;.format(loader))
    for (record &lt;- loader.load)
      db.singleInsert(0, record.key.getBytes, serializer.serialize(record), null)
    println(&quot; done&quot;)
  }
}</code></pre>
      </td>
    </tr>
    <tr id="section-1">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-1">#</a>
        </div>
      <p>Embedded key/value store. More efficient than naive memory db, but local, thus in our scenario the initial data has to be loaded from another loader.</p>

      </td>
      <td class="code">
        <pre class="scala"><code>class BabuDBFetcher[A &lt;: Keyed] @Inject() (val dbName: String, val loader: Loader[A], val serializer: Serializer[A]) extends Fetcher[A] with BabuDB[A] {

  def fetch(start: String, size: Long) = {
    val res = db.prefixLookup(0, start.getBytes, null)
    res.get.take(size.toInt).map { x =&gt; serializer.deserialize(x.getValue) }.toIterable
  }

  override def shutdown = stop
}

class BabuDBLoader[A &lt;: Keyed] @Inject() (val dbName: String, val loader: Loader[A], val serializer: Serializer[A]) extends Loader[A] with BabuDB[A] {

  def load = {
    val res = db.prefixLookup(0, &quot;&quot;.getBytes, null)
    res.get.map { x =&gt; serializer.deserialize(x.getValue) }.toIterable
  }

  override def shutdown = stop
}</code></pre>
      </td>
    </tr>
  </table>
</div>
</body>
</html>