<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>COMPSs.scala</title>
  <link href="http://circumflex.ru/css/docco.css"
        rel="stylesheet"
        type="text/css"
        media="screen, projection"/>
  <script type="text/javascript" src="http://circumflex.ru/js/highlight.pack.js">
  </script>
  <script type="text/javascript">
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>
<div id="container">
  <table cellspacing="0" cellpadding="0">
    <thead>
    <tr>
      <th class="docs">
        <h1><a href="../../../index.html" title="Back to index">&larr;</a>&nbsp;&nbsp;COMPSs.scala</h1>
      </th>
      <th class="code"></th>
    </tr>
    </thead>
    <tbody>
    <tr id="section-0">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-0">#</a>
        </div>
      
      </td>
      <td class="code">
        <pre class="scala"><code>package it.cnr.aquamaps

import com.google.inject._
import scala.xml.{ Node, Text, XML }
import scala.xml.Utility.trim
import io.Source.fromFile
import java.io.File
import com.google.inject._
import com.google.inject.util.{ Modules =&gt; GuiceModules }
import uk.me.lings.scalaguice.InjectorExtensions._
import uk.me.lings.scalaguice.ScalaModule
import Watch.timed
import java.io._
import org.apache.commons.io.IOUtils
import resource._</code></pre>
      </td>
    </tr>
    <tr id="section-1">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-1">#</a>
        </div>
      <h1>COMPSs support</h1>
<p>COMPSs currently only support files as communication method between remote spawns.</p>

      </td>
      <td class="code">
        <pre class="scala"><code></code></pre>
      </td>
    </tr>
    <tr id="section-2">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-2">#</a>
        </div>
      <p>Hencefore we needa way to serialize Partitions to and from xml: this import adds the <code>toXml</code> and <code>toPartition</code> methods to <code>Partition</code> and <code>xml.Node</code> respectively, see bottom.</p>

      </td>
      <td class="code">
        <pre class="scala"><code>import P2XML._</code></pre>
      </td>
    </tr>
    <tr id="section-3">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-3">#</a>
        </div>
      <p>In order to connect to the rest of the system, first we implement the <code>Generator</code> interface. We receive partitions from the entry point here, convert the parameters  * into files, amd delegate to another interface whose signature COMPSs knowns how to handle (files as parameters).</p>

      </td>
      <td class="code">
        <pre class="scala"><code>class COMPSsGenerator @Inject() (val delegate: FileParamsGenerator, val emitter: COMPSsCollectorEmitter[HSPEC]) extends Generator {

  def computeInPartition(p: Partition) {
    val tmpFile = mkTmp(&quot;.xml&quot;)
    XML.save(tmpFile, p.toXml)

    val outputFile = mkTmp(&quot;.csv.gz&quot;)

    delegate.computeInPartition(tmpFile, outputFile)</code></pre>
      </td>
    </tr>
    <tr id="section-4">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-4">#</a>
        </div>
      <p>Keep it for later</p>

      </td>
      <td class="code">
        <pre class="scala"><code>    emitter.add(outputFile)
  }

  def mkTmp(ext: String) = {
    val file = File.createTempFile(&quot;rainycloud&quot;, ext)
    file.deleteOnExit()
    file.toString
  }
}</code></pre>
      </td>
    </tr>
    <tr id="section-5">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-5">#</a>
        </div>
      <p>We would like to defer the merging of the results until we spawned all the tasks</p>

      </td>
      <td class="code">
        <pre class="scala"><code>class COMPSsCollectorEmitter[A] @Inject() (val tableWriter: TableWriter[A]) extends Emitter[A] {
  var list: List[String] = List()

  def emit(record: A) = throw new IllegalArgumentException(&quot;this emitter cannot be used directly&quot;)

  def add(fileName: String) = list = fileName :: list</code></pre>
      </td>
    </tr>
    <tr id="section-6">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-6">#</a>
        </div>
      <p>The actual merging is invoked upon emitter flush, which is called at the end of the job.</p>

      </td>
      <td class="code">
        <pre class="scala"><code>  def flush {
    println(&quot;merging results into %s&quot;.format(tableWriter))
    timed(&quot;merging&quot;) {
      for {
        fw &lt;- managed(tableWriter.writer)
        file &lt;- list
      } merge(file, fw)
    }
  }</code></pre>
      </td>
    </tr>
    <tr id="section-7">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-7">#</a>
        </div>
      <p>We have to call a static method for COMPSs to be able to track this call and managed dependencies.</p>

      </td>
      <td class="code">
        <pre class="scala"><code>  def merge(fileName: String, out: Writer) {
    COMPSsCollectorEmitter.merge(fileName, out)
  }
}

object COMPSsCollectorEmitter {</code></pre>
      </td>
    </tr>
    <tr id="section-8">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-8">#</a>
        </div>
      <p>We assume we can perform a nice low level concatenation of the parts.</p>

      </td>
      <td class="code">
        <pre class="scala"><code>  def merge(fileName: String, out: Writer) {
    timed(&quot;merging %s&quot;.format(fileName)) {
      for (in &lt;- managed(new FileSystemTableReader(fileName).reader))
        IOUtils.copy(in, out)
    }
  }
}</code></pre>
      </td>
    </tr>
    <tr id="section-9">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-9">#</a>
        </div>
      <p>Now here's the magic. This method accepts files and converts them back to our native parameters and delegates to another Generator (I still don't know if we have to pass java <code>Files</code> or file names.)</p>

      </td>
      <td class="code">
        <pre class="scala"><code>trait FileParamsGenerator {
  def computeInPartition(fileName: String, outputFileName: String)
}</code></pre>
      </td>
    </tr>
    <tr id="section-10">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-10">#</a>
        </div>
      <p>The <code>FileParamsGenerator</code> above is just an abstract trait, we need a way to find the backend generator.  If we are running within a real application it's easy: just let Guice inject it!</p>

      </td>
      <td class="code">
        <pre class="scala"><code>class SimpleFileParamsGenerator @Inject() (val delegate: Generator, val emitter: Emitter[HSPEC]) extends FileParamsGenerator {
  def computeInPartition(fileName: String, outputFileName: String) {
    delegate.computeInPartition(XML.load(fileName).toPartition)
    emitter.flush
  }
}</code></pre>
      </td>
    </tr>
    <tr id="section-11">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-11">#</a>
        </div>
      <p>But what if COMPSs requires only static method invocations because it wouldn't know how to spawn the instances on the remote worker ?</p>

      </td>
      <td class="code">
        <pre class="scala"><code>class StaticFileParamsGenerator extends FileParamsGenerator {
  def computeInPartition(fileName: String, outputFileName: String) = StaticFileParamsGenerator.staticDelegate(fileName, outputFileName)
}</code></pre>
      </td>
    </tr>
    <tr id="section-12">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-12">#</a>
        </div>
      <p>The static delegate also returns the output filename so that COMPSs can move the data for us.</p>

      </td>
      <td class="code">
        <pre class="scala"><code>object StaticFileParamsGenerator {

  case class COMPSsWorkerModule(val outputFileName: String) extends AbstractModule with ScalaModule {
    def configure() {</code></pre>
      </td>
    </tr>
    <tr id="section-13">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-13">#</a>
        </div>
      <p>Let's write to a temporary file, so that the same machine can host several instances of this worker. In order to do this        we override the Guice config and inject another TableWriter.</p>

      </td>
      <td class="code">
        <pre class="scala"><code>      val writer: FileSystemTableWriter[HSPEC] = new FileSystemTableWriter(outputFileName)

      bind[TableWriter[HSPEC]].toInstance(writer)
      bind[FileSystemTableWriter[HSPEC]].toInstance(writer)</code></pre>
      </td>
    </tr>
    <tr id="section-14">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-14">#</a>
        </div>
      <p>The static method will just delegate the work to the <code>SimpleFileParamsGenerator</code></p>

      </td>
      <td class="code">
        <pre class="scala"><code>      bind[FileParamsGenerator].to[SimpleFileParamsGenerator]
    }
  }

  def staticDelegate(fileName: String, outputFileName: String) {
    withInjector(outputFileName) { injector =&gt;
      val generator = injector.instance[FileParamsGenerator]
      generator.computeInPartition(fileName, outputFileName)
    }
  }</code></pre>
      </td>
    </tr>
    <tr id="section-15">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-15">#</a>
        </div>
      <p>Currently Guice has no support for shutting down an injector, so we have to do it manually</p>

      </td>
      <td class="code">
        <pre class="scala"><code>  def withInjector[A](outputFileName: String)(body: Injector =&gt; A) = {</code></pre>
      </td>
    </tr>
    <tr id="section-16">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-16">#</a>
        </div>
      <p>We have to create a new DI context, since we run in a static method (and possibly on another machine, in a completely disconnected runtime context)</p>

      </td>
      <td class="code">
        <pre class="scala"><code>    val i = Guice createInjector (GuiceModules `override` AquamapsModule() `with` (COMPSsWorkerModule(outputFileName), COMPSsWorkerHDFSModule(), BabuDBModule()))
    val res = body(i)
    i.instance[Fetcher[HCAF]].shutdown
    i.instance[Loader[HSPEN]].shutdown
    res
  }
}</code></pre>
      </td>
    </tr>
    <tr id="section-17">
      <td class="docs">
        <div class="octowrap">
          <a class="octothorpe" href="#section-17">#</a>
        </div>
      <h2>Serialization</h2>
<p>These are details, we need some (de)serialization for partition descriptors. Let's go for a readable choice:</p>

      </td>
      <td class="code">
        <pre class="scala"><code>class P2XML(val p: Partition) {
  def toXml() = {
    &lt;partition&gt;
      &lt;start&gt;{ p.start }&lt;/start&gt;
      &lt;size&gt;{ p.size }&lt;/size&gt;
    &lt;/partition&gt;
  }
}

class XML2P(val p: Node) {
  def toPartition: Partition = trim(p) match {
    case &lt;partition&gt;&lt;start&gt;{ start }&lt;/start&gt;&lt;size&gt;{ size }&lt;/size&gt;&lt;/partition&gt; =&gt; new Partition(start.text, size.text.toLong)
  }
}

object P2XML {
  implicit def p2xml(p: Partition): P2XML = new P2XML(p)
  implicit def p2xml(p: Node): XML2P = new XML2P(p)
}</code></pre>
      </td>
    </tr>
  </table>
</div>
</body>
</html>